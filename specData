#!/usr/bin/python
'''
General plan:
    use scikits.audiolab to get data bit by bit
    fft the samples --> get the spectrum
'''
import numpy as np
from functools import reduce
from scikits.audiolab import Sndfile
import sys

#### Some extra-info
#
#
# piano is from ~27hz to ~4200hz
#
####

####### VARIABLES/FUNCTIONS OF DOOM

#for future, pass the uri to the script
audio_file = sys.argv[1]

# number of bands
bands = 50

#total slices or w/e
total_fouriers = 2000

#the window size (i.e., number of samples) for each fft
fourier_window = np.float(1024)

def bounds():
    # define ranges of frequencies (hz) to blend
    # i could do this automatically, but w/e
    # basically, up to ~100hz, blend into one, from 100-2000
    # skip every 10 hz, 2k+ blend into one
    bounds = [ 
                [0,100],
            ]

    start = bounds[-1][1]
    step = 10
    while start < 2000:
        bounds.append([start,start+step])
        start += step

    bounds.append([start])
    return bounds

def fft(samples):
    #abs of fast fourier transform
    return np.abs(np.fft.rfft(samples)) 

def bandwidth(sample_size, sample_rate):
    #return bandwidth
    return np.multiply(np.true_divide(2, sample_size), np.true_divide(sample_rate, 2))

def freqs(sample_size, sample_rate):
    #frequency for each index
    f = np.true_divide(sample_rate, np.true_divide(sample_size, 2))
    p=[k * f for k in range(int(sample_size))]
    return p[:int(np.floor_divide(sample_size,2))+1]

####### END VARIABLES/FUNCTIONS OF DOOM


########### GET THE AUDIO DATA

f = Sndfile(audio_file, "r")

# some germane
# f properties..
    #   samplerate = samplerate of the file
    #   nframes = total number of frames in the file
    #   channels = number of channels in the file
#   methods...
    #   read_frames(x) = read x number of frames, moves index
    #   seek(x) = move to frame number x

#length of file (in secs) very rough
time_length = f.nframes / f.samplerate

# fouriers per second of sample
fouriers_per_second = total_fouriers / time_length

#frame step between each fft
fourier_step = np.floor_divide(f.nframes, total_fouriers)

#print fouriers_per_second
#sys.exit(0)

# print the info, if one wants
print "samplerate:",f.samplerate
print "total frames:",f.nframes
print "window_size:",fourier_window
print "# of ffts:", total_fouriers
print "step:",fourier_step
print "length:", time_length, "seconds"

# go through parts of file, chunk by chunk, with seeks

#frame starts for each fourier

i=0
spectrum_data = []
for window in range(total_fouriers):
    #print "fourier #:",window, "i:",i
    f.seek(i)
    if f.channels == 1:
        chunk = f.read_frames(fourier_window)

    else:
        #average the channels
        chunk = []
        for frame in f.read_frames(fourier_window):
            avg = np.true_divide(np.sum(frame), fourier_window)
            chunk.append(avg)
    
    spectrum_data.append(fft(chunk))
    i+=fourier_step

# Have spectrum data in array, yay!!!!

# average the shit into w/e number of bands, optimize since this is stupid slow
# bad coding by me, really bad coding
# i calculate the same thing over and over...stupid fucking stupid
freq_bounds = bounds()
freq_index = freqs(sample_size, f.sample_rate)

#now I need to determine for the indices where they belong in the bounds
# really stupid way to do this, but wtf, I suck at coding
indices=[]
lower = 0  #inclusive
upper = 0  #inclusive
for bound in freq_bounds:
    for i,freq in enumerate(freq_index):
        if bound[0] <= freq <= bound[1]:
            upper = i
    indices.append([lower,upper])

            
            

#average based on indices values
a = []
for s in indices:
    a.append((a, np.mean(spectrum_data[...,s[0]:s[1]+1], axis=1)))

a = np.concatenate(a, axis=1)
print a
sys.exit(0)
print "after"


# we are going to write to a file
#import json
from StringIO import StringIO
fp = StringIO()

# write part of desired format, 
# probably can do this through json.dump
# but fucked if i know how
fp.write("data[0] = {title: 'blar', timecode: [")

# calculate very roughly millisecond difference b/w each sample
time_step = np.reciprocal(np.float(fouriers_per_second)) * 1000
#print time_step, "ms b/w each sampling"

# time window for each sample set (in ms)
window_time = (time_length / fourier_window) * 1000
#print window_time, "ms for each sample set"

#find max value in fft, needed for scaling
high=np.amax(a)

for k,v in enumerate(a):
    # calculte time (in ms) for each sample
    time = int(np.floor((k * time_step) + (.5 * window_time)))
    #print time, "milliseconds"

    #scale values to between 0-255
    scale = 255 / high # (high - low) but low = 0, more or less
    tmp = np.multiply(v, scale)
    tmp = np.round(tmp)
    tmp = np.asarray(tmp,dtype=int)

    # write to file object
    fp.write('{t:' + str(time) + ',p:' + str(tmp.tolist()) + '}')
    if k == len(a) - 1:
        continue
    else:
        fp.write(',')

fp.write("]};")
contents = fp.getvalue()
fp.close()

# write to file
with open("/home/cz/d.txt", "w") as p:
    p.write(contents)
